public static class SearchEngineHelper
    {
        public static string RemoveDiacritics(string stIn)
        {
            string stFormD = stIn.Normalize(NormalizationForm.FormD);
            StringBuilder sb = new StringBuilder();

            for (int ich = 0; ich < stFormD.Length; ich++)
            {
                UnicodeCategory uc = CharUnicodeInfo.GetUnicodeCategory(stFormD[ich]);
                if (uc != UnicodeCategory.NonSpacingMark)
                {
                    sb.Append(stFormD[ich]);
                }
            }

            return (sb.ToString().Normalize(NormalizationForm.FormC));
        }

        public static string[] GetTabMotsCles_old(string MotsCles)
        {
            MotsCles = MotsCles.Trim('?');
            MotsCles = MotsCles.Trim();

            string[] _mcTab = MotsCles.Split(' ');
            string[] _motsCles = new string[_mcTab.Length + 1];
            for (int i = 0; i < _mcTab.Length; i++)
            {
                _motsCles[i] = _mcTab[i];
            }
            _motsCles[_motsCles.Length - 1] = MotsCles;
            return _motsCles;
        }

        /// <summary>
        /// Décompose le texte saisi en un tableau de 1, 2, 3, etc. mots successifs
        /// La recherche par mots-clés portera sur chacun de ces éléments
        /// </summary>
        /// <param name="MotsCles">texte saisi</param>
        /// <returns>tableau d'éléments à rechercher</returns>
        public static string[] GetTabMotsCles(string MotsCles)
        {
            MotsCles = MotsCles.Trim('?');
            MotsCles = MotsCles.Trim();

            string[] _mcTab = MotsCles.Split(' ');// Stocke les éléments simples
            IList<string> composes = new List<string>(); // Stocke les éléments composés obtenus

            if (_mcTab.Length > 1)
            {
                // Pour chaque longueur len de 1 à Nbr mots saisis-1
                for (int len = 1; len < _mcTab.Length; len++)
                {
                    // Pour chaque offset possible tout en restant à l'intérieur du tableau
                    for (int offs = 0; offs <= _mcTab.Length - len; offs++)
                    {
                        string str = String.Empty;
                        // On parcours la longueur len dans le texte saisi
                        for (int i = 0; i < len; i++)
                        {
                            if (str == String.Empty)
                            {
                                str = _mcTab[offs + i];
                            }
                            else
                            {
                                str += " " + _mcTab[offs + i];
                            }
                        }
                        composes.Add(str);
                    }
                }
            }

            string[] _motsCles = new string[composes.Count + 1];
            int j = 0;
            foreach (string str in composes)
            {
                _motsCles[j] = str;
                j++;
            }
            _motsCles[_motsCles.Length - 1] = MotsCles;
            return _motsCles;
        }

        /// <summary>
        /// Ajoute des mots-clés pour chaque partie d'un mot-clé saisi avec un caractère spécial à l'intérieur : trait d'union ou apostrophe
        /// </summary>
        /// <param name="_motsCles"></param>
        /// <returns></returns>
        public static string[] GereCaracteresSpeciaux(string[] _motsCles)
        {
            List<string> _temp = _motsCles.ToList();

            for (int i = 0; i < _motsCles.Length; i++)
            {
                AjouteParties(_motsCles, _temp, i, '-');
            }
            _motsCles = _temp.ToArray();

            for (int i = 0; i < _motsCles.Length; i++)
            {
                AjouteParties(_motsCles, _temp, i, '\'');
            }
            _motsCles = _temp.ToArray();

            return _motsCles;
        }

        private static void AjouteParties(string[] _motsCles, List<string> _temp, int i, Char caractereSpecial)
        {
            string[] motCle = _motsCles[i].Split(caractereSpecial);
            if (motCle.Count() > 1)
            {
                for (int j = 0; j < motCle.Length; j++)
                {
                    string partieMotCle = motCle[j].Trim();
                    if (!String.IsNullOrEmpty(partieMotCle))
                    {
                        _temp.Add(partieMotCle);
                    }
                }
            }
        }

        /// <summary>
        /// Traite les pluriels et les adjectifs au féminin
        /// Ajoute un mot clé sans S ou E pour chaque mot-clé saisi se terminant par un S ou un E
        /// Traite aussi le cas de mots composés pluriels ("...s-...s")
        /// </summary>
        /// <param name="_motsCles"></param>
        /// <returns></returns>
        public static string[] GerePlurielsEtFeminins(string[] _motsCles) //  (et éventuellement les "e" en fin de mot)
        {
            List<string> _temp = _motsCles.ToList();
            for (int i = 0; i < _motsCles.Length; i++)
            {
                string motCle = _motsCles[i];
                if (motCle.Length > 0)
                {
                    string derniereLettre = motCle.Substring(motCle.Length - 1).ToLower();
                    if (derniereLettre.Equals("s"))
                    {
                        string[] tabString = motCle.Split('-');
                        if (tabString.Count() > 1 && tabString[0].Length > 1 && motCle.Substring(tabString[0].Length - 1, 1).ToLower().Equals("s") && tabString[1].Length > 1)
                        {
                            // Cas des mots-composés avec un 's' avant le trait d'union : on l'enlève aussi
                            string premierePartie = motCle.Substring(0, tabString[0].Length - 1);
                            string deuxiemePartie = motCle.Substring(tabString[0].Length + 1, tabString[1].Length - 1);
                            _temp.Add(String.Concat(premierePartie, "-", deuxiemePartie));
                        }
                        else
                        {
                            _temp.Add(motCle.Substring(0, motCle.Length - 1));
                        }
                    }
                    else if (derniereLettre.Equals("e"))
                    {
                        _temp.Add(motCle.Substring(0, motCle.Length - 1));
                    }
                }
            }
            _motsCles = _temp.ToArray();
            return _motsCles;
        }

        // Pour la gestion des accents, on peut soit faire une requête par mot-clé saisi (voir le temps nécessaire),
        // Soit rester sur une seule requête mais utiliser une colonne supplémentaire, genre "normalizedLibelle",avec des triggers sur insert et update
        // cf. plus bas pour remplir ce champ
    }